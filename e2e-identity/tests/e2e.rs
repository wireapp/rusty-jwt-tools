#![cfg(not(target_family = "wasm"))]

use std::ops::Deref;

use jwt_simple::prelude::*;
use testcontainers::clients::Cli;

use rusty_acme::prelude::{stepca::CaCfg, *};
use rusty_jwt_tools::prelude::*;
use utils::{
    cfg::{E2eTest, EnrollmentFlow},
    rand_base64_str,
};

use crate::utils::TestError;

#[path = "utils/mod.rs"]
mod utils;

fn docker() -> &'static Cli {
    Box::leak(Box::new(Cli::docker()))
}

/// Tests the nominal case and prints the pretty output with the mermaid chart in this crate README.
#[cfg(not(ci))]
#[tokio::test]
async fn demo_should_succeed() {
    let test = E2eTest::new_demo().start(docker()).await;

    assert!(test.nominal_enrollment().await.is_ok());
}

/// Verify that it works for all MLS ciphersuites
#[cfg(not(ci))]
mod alg {
    use super::*;

    #[tokio::test]
    async fn ed25519_should_succeed() {
        let test = E2eTest::new().with_alg(JwsAlgorithm::Ed25519).start(docker()).await;

        assert!(test.nominal_enrollment().await.is_ok());
    }

    #[tokio::test]
    async fn p256_should_succeed() {
        let test = E2eTest::new().with_alg(JwsAlgorithm::P256).start(docker()).await;

        assert!(test.nominal_enrollment().await.is_ok());
    }

    // TODO: Fails because of hardcoded SHA-256 hash algorithm in stepca
    #[ignore]
    #[tokio::test]
    async fn p384_should_succeed() {
        let test = E2eTest::new().with_alg(JwsAlgorithm::P384).start(docker()).await;

        assert!(test.nominal_enrollment().await.is_ok());
    }
}

/// Since the acme server is a fork, verify its invariants are respected
#[cfg(not(ci))]
mod acme_server {
    use super::*;

    /// Challenges returned by ACME server are mixed up
    #[should_panic]
    #[tokio::test]
    async fn should_fail_when_no_replay_nonce_requested() {
        let test = E2eTest::new().start(docker()).await;

        let flow = EnrollmentFlow {
            get_acme_nonce: Box::new(|test, _| {
                Box::pin(async move {
                    // this replay nonce has not been generated by the acme server
                    let unknown_replay_nonce = rand_base64_str(42);
                    Ok((test, unknown_replay_nonce))
                })
            }),
            ..Default::default()
        };
        test.enrollment(flow).await.unwrap();
    }

    /// Replay nonce is reused by the client
    #[should_panic]
    #[tokio::test]
    async fn should_fail_when_replay_nonce_reused() {
        let test = E2eTest::new().start(docker()).await;

        let flow = EnrollmentFlow {
            new_order: Box::new(|mut test, (directory, account, previous_nonce)| {
                Box::pin(async move {
                    // same nonce is used for both 'new_order' & 'new_authz'
                    let (order, order_url, _previous_nonce) =
                        test.new_order(&directory, &account, previous_nonce.clone()).await?;
                    let (_, previous_nonce) = test.new_authz(&account, order.clone(), previous_nonce).await?;
                    Ok((test, (order, order_url, previous_nonce)))
                })
            }),
            ..Default::default()
        };
        test.enrollment(flow).await.unwrap();
    }

    /// Challenges returned by ACME server are mixed up
    #[tokio::test]
    async fn should_fail_when_challenges_inverted() {
        let test = E2eTest::new().start(docker()).await;

        let flow = EnrollmentFlow {
            extract_challenges: Box::new(|mut test, authz| {
                Box::pin(async move {
                    let (dpop_chall, oidc_chall) = test.extract_challenges(authz)?;
                    // let's invert those challenges for the rest of the flow
                    Ok((test, (oidc_chall, dpop_chall)))
                })
            }),
            ..Default::default()
        };
        assert!(matches!(
            test.enrollment(flow).await.unwrap_err(),
            TestError::Acme(RustyAcmeError::ClientImplementationError(
                "a challenge is not supposed to be pending at this point. It must either be 'valid' or 'processing'."
            ))
        ));
    }
}

#[cfg(not(ci))]
mod client_id_challenge {
    use crate::utils::rand_client_id;

    use super::*;

    /// Demonstrates that the client possesses the clientId. Client makes an authenticated request
    /// to wire-server, it delivers a nonce which the client seals in a signed DPoP JWT.
    #[should_panic]
    #[tokio::test]
    async fn should_fail_when_client_dpop_token_has_wrong_backend_nonce() {
        let test = E2eTest::new().start(docker()).await;

        let flow = EnrollmentFlow {
            create_dpop_token: Box::new(|mut test, (dpop_chall, backend_nonce)| {
                Box::pin(async move {
                    // use a different nonce than the supplied one
                    let wrong_nonce = rand_base64_str(32).into();
                    assert_ne!(wrong_nonce, backend_nonce);

                    let client_dpop_token = test.create_dpop_token(&dpop_chall, wrong_nonce).await?;
                    Ok((test, client_dpop_token))
                })
            }),
            ..Default::default()
        };
        test.enrollment(flow).await.unwrap();
    }

    /// Acme server should be configured with wire-server public key to verify the access tokens
    /// issued by wire-server.
    #[tokio::test]
    async fn should_fail_when_access_token_not_signed_by_wire_server() {
        let default = E2eTest::new();
        let wrong_backend_kp = Ed25519KeyPair::generate();
        let test = E2eTest {
            ca_cfg: CaCfg {
                sign_key: wrong_backend_kp.public_key().to_pem(),
                ..default.ca_cfg
            },
            ..default
        };
        let test = test.start(docker()).await;
        assert!(matches!(
            test.nominal_enrollment().await.unwrap_err(),
            TestError::Acme(RustyAcmeError::ChallengeError(AcmeChallError::Invalid))
        ));
    }

    /// The access token has a 'chal' claim which should match the Acme challenge 'token'.
    /// This is verified by the acme server
    #[tokio::test]
    async fn should_fail_when_access_token_challenge_claim_is_not_current_challenge_one() {
        let test = E2eTest::new().start(docker()).await;

        let flow = EnrollmentFlow {
            create_dpop_token: Box::new(|mut test, (dpop_chall, backend_nonce)| {
                Box::pin(async move {
                    // alter the 'token' of the valid challenge
                    let wrong_dpop_chall = AcmeChallenge {
                        token: rand_base64_str(32),
                        ..dpop_chall
                    };
                    let client_dpop_token = test.create_dpop_token(&wrong_dpop_chall, backend_nonce).await?;
                    Ok((test, client_dpop_token))
                })
            }),
            ..Default::default()
        };
        assert!(matches!(
            test.enrollment(flow).await.unwrap_err(),
            TestError::Acme(RustyAcmeError::ChallengeError(AcmeChallError::Invalid))
        ));
    }

    /// We first set a clientId for the enrollment process when we create the acme order. This same
    /// clientId must be used and sealed in the accessToken which is verified by the acme server in
    /// the oidc challenge. The challenge should be invalid if they differ
    #[tokio::test]
    async fn should_fail_when_access_token_client_id_mismatches() {
        let test = E2eTest::new().start(docker()).await;

        let flow = EnrollmentFlow {
            new_order: Box::new(|mut test, (directory, account, previous_nonce)| {
                Box::pin(async move {
                    // just alter the clientId for the order creation...
                    let sub = test.sub.clone();
                    test.sub = rand_client_id();
                    let (order, order_url, previous_nonce) =
                        test.new_order(&directory, &account, previous_nonce).await?;
                    // ...then resume to the regular one to create the client dpop token & access token
                    test.sub = sub;
                    Ok((test, (order, order_url, previous_nonce)))
                })
            }),
            ..Default::default()
        };
        assert!(matches!(
            test.enrollment(flow).await.unwrap_err(),
            TestError::Acme(RustyAcmeError::ChallengeError(AcmeChallError::Invalid))
        ));
    }
}

#[cfg(not(ci))]
mod oidc_error {
    use super::*;

    #[tokio::test]
    async fn should_fail_when_oidc_provider_jwks_uri_unavailable() {
        let mut test = E2eTest::new();
        // invalid jwks uri
        let mut jwks_uri: url::Url = test.ca_cfg.jwks_uri.parse().unwrap();
        jwks_uri.set_port(Some(jwks_uri.port().unwrap() + 1)).unwrap();
        test.ca_cfg.jwks_uri = jwks_uri.to_string();
        let test = test.start(docker()).await;

        // cannot validate the OIDC challenge
        assert!(test.nominal_enrollment().await.is_err());
    }
}

/// Further improvements
#[cfg(not(ci))]
mod optimize {
    use super::*;

    #[tokio::test]
    async fn should_validate_challenges_in_parallel() {
        let docker = Box::leak(Box::new(Cli::docker()));
        let mut test = E2eTest::new().start(docker).await;
        let directory = test.get_acme_directory().await.unwrap();
        let previous_nonce = test.get_acme_nonce(&directory).await.unwrap();
        let (account, previous_nonce) = test.new_account(&directory, previous_nonce).await.unwrap();
        let (order, order_url, previous_nonce) = test.new_order(&directory, &account, previous_nonce).await.unwrap();
        let (authz, previous_nonce) = test.new_authz(&account, order, previous_nonce).await.unwrap();
        let (dpop_chall, oidc_chall) = test.extract_challenges(authz).unwrap();

        let test = std::sync::Arc::new(tokio::sync::Mutex::new(test));
        let t1 = test.clone();
        let account = std::sync::Arc::new(account);
        let acc1 = account.clone();

        let previous_nonce = tokio::task::spawn(async move {
            let mut test = t1.lock().await;
            let backend_nonce = test.get_wire_server_nonce().await.unwrap();
            let client_dpop_token = test.create_dpop_token(&dpop_chall, backend_nonce).await.unwrap();
            let access_token = test.get_access_token(client_dpop_token).await.unwrap();
            let previous_nonce = test
                .verify_dpop_challenge(&acc1, dpop_chall, access_token, previous_nonce)
                .await
                .unwrap();
            previous_nonce
        })
        .await
        .unwrap();

        let t2 = test.clone();
        let acc2 = account.clone();

        tokio::task::spawn(async move {
            let mut test = t2.lock().await;
            let previous_nonce = test.get_acme_nonce(&directory).await.unwrap();
            let id_token = test.fetch_id_token().await.unwrap();
            test.verify_oidc_challenge(&acc2, oidc_chall, id_token, previous_nonce)
                .await
                .unwrap();
        })
        .await
        .unwrap();

        let mut test = test.lock().await;
        let (order, previous_nonce) = test
            .verify_order_status(&account, order_url, previous_nonce)
            .await
            .unwrap();
        let (finalize, previous_nonce) = test.finalize(&account, order, previous_nonce).await.unwrap();
        test.get_x509_certificates(account.deref().clone(), finalize, previous_nonce)
            .await
            .unwrap();
    }
}
