use jwt_simple::prelude::*;

use rusty_jwt_tools::prelude::*;

#[test]
fn e2e_test() {
    let keys: Vec<(JwsAlgorithm, Pem, Pem, HashAlgorithm)> = vec![
        (
            JwsAlgorithm::P256,
            ES256KeyPair::generate().to_pem().unwrap().into(),
            ES256KeyPair::generate().to_pem().unwrap().into(),
            HashAlgorithm::SHA256,
        ),
        (
            JwsAlgorithm::P384,
            ES384KeyPair::generate().to_pem().unwrap().into(),
            ES384KeyPair::generate().to_pem().unwrap().into(),
            HashAlgorithm::SHA384,
        ),
        (
            JwsAlgorithm::Ed25519,
            Ed25519KeyPair::generate().to_pem().into(),
            Ed25519KeyPair::generate().to_pem().into(),
            HashAlgorithm::SHA256,
        ),
    ];

    let mut results = vec![];

    for (alg, key, backend_keys, hash_alg) in keys {
        println!("# {:?} - {:?}", alg, hash_alg);

        let nonce: BackendNonce = "WE88EvOBzbqGerznM+2P/AadVf7374y0cH19sDSZA2A".into(); // generated by wire-server
        let challenge: AcmeChallenge = "okAJ33Ym/XS2qmmhhh7aWSbBlYy4Ttm1EysqW8I/9ng".to_string().into(); // generated by ACME server
        let alice = QualifiedClientId::new("alice", 1, "wire.com");
        let htu: Htu = "https://wire.example.com/client/token".try_into().unwrap();
        let htm = Htm::Post;
        let leeway: u16 = 5;
        let max_expiration: u64 = 2136351646; // somewhere in 2037
        let dpop = Dpop {
            htu: htu.clone(),
            htm,
            challenge: challenge.clone(),
            extra_claims: None,
        };

        // Wire app generates a DPoP JWT token
        let client_dpop = RustyJwtTools::generate_dpop_token(alg, key.clone(), dpop, nonce.clone(), alice).unwrap();

        println!("1. generate dpop:\nhttps://jwt.io/#id_token={}\n", client_dpop);

        // wire-server now validates the 'client_dpop' and generates an access token
        let access_token = RustyJwtTools::generate_access_token(
            &client_dpop,
            alice,
            nonce.clone(),
            htu.clone(),
            htm,
            leeway,
            max_expiration,
            backend_keys.clone(),
            hash_alg,
        )
        .unwrap();

        println!("2. generate access token:\nhttps://jwt.io/#id_token={}\n", access_token);

        // now acme server will verify the access token
        let backend_pk = match alg {
            JwsAlgorithm::P256 => ES256KeyPair::from_pem(backend_keys.as_str())
                .unwrap()
                .public_key()
                .to_pem()
                .unwrap(),
            JwsAlgorithm::P384 => ES384KeyPair::from_pem(backend_keys.as_str())
                .unwrap()
                .public_key()
                .to_pem()
                .unwrap(),
            JwsAlgorithm::Ed25519 => Ed25519KeyPair::from_pem(backend_keys.as_str())
                .unwrap()
                .public_key()
                .to_pem(),
        }
        .into();
        let verify = RustyJwtTools::verify_access_token(
            &access_token,
            alice,
            challenge,
            leeway,
            max_expiration,
            backend_pk,
            hash_alg,
        );
        println!("3. access token verified '{}'\n", verify.is_ok());
        results.push(verify);
        println!("---------------------------------------------------------------------\n");
    }
    assert!(results.into_iter().all(|v| v.is_ok()));
}
