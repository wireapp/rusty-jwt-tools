use std::fmt::Formatter;

use serde::{Deserialize, Serialize};

use crate::prelude::*;

/// Nonce generated by the acme server.
/// Also called `challenge`, it is used for authentication challenge
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct AcmeChallenge(String);

impl From<String> for AcmeChallenge {
    fn from(challenge: String) -> Self {
        Self(challenge)
    }
}

impl From<AcmeChallenge> for String {
    fn from(challenge: AcmeChallenge) -> Self {
        challenge.0
    }
}

impl std::ops::Deref for AcmeChallenge {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::fmt::Display for AcmeChallenge {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
impl Default for AcmeChallenge {
    fn default() -> Self {
        Self(rand_nonce(32))
    }
}

/// Nonce generated by [wire-server](https://github.com/wireapp/wire-server)
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct BackendNonce(String);

impl From<String> for BackendNonce {
    fn from(nonce: String) -> Self {
        Self(nonce)
    }
}

impl From<BackendNonce> for String {
    fn from(nonce: BackendNonce) -> Self {
        nonce.0
    }
}

impl std::ops::Deref for BackendNonce {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::fmt::Display for BackendNonce {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
impl Default for BackendNonce {
    fn default() -> Self {
        Self(rand_nonce(32))
    }
}

#[cfg(test)]
fn rand_nonce(size: usize) -> String {
    use rand::distributions::{Alphanumeric, DistString};
    let challenge: String = Alphanumeric.sample_string(&mut rand::thread_rng(), size);
    base64::encode_config(challenge, base64::URL_SAFE_NO_PAD)
}
