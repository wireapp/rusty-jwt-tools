use std::fmt::Formatter;

use serde::{Deserialize, Serialize};

use crate::prelude::*;

/// Nonce generated by the acme server.
/// Also called `challenge`, it is used for authentication challenge
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct AcmeChallenge(String);

impl From<String> for AcmeChallenge {
    fn from(challenge: String) -> Self {
        Self(challenge)
    }
}

impl From<AcmeChallenge> for String {
    fn from(challenge: AcmeChallenge) -> Self {
        challenge.0
    }
}

impl std::ops::Deref for AcmeChallenge {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::fmt::Display for AcmeChallenge {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
impl AcmeChallenge {
    pub fn rand() -> Self {
        Self(rand_nonce(32))
    }
}

#[cfg(test)]
impl Default for AcmeChallenge {
    fn default() -> Self {
        Self("okAJ33Ym/XS2qmmhhh7aWSbBlYy4Ttm1EysqW8I/9ng".to_string())
    }
}

/// Nonce generated by [wire-server](https://github.com/wireapp/wire-server)
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct BackendNonce(String);

impl BackendNonce {
    /// From bytes
    pub fn try_from_bytes(bytes: &[u8]) -> RustyJwtResult<Self> {
        Ok(core::str::from_utf8(bytes)?.into())
    }
}

impl From<String> for BackendNonce {
    fn from(nonce: String) -> Self {
        Self(nonce)
    }
}

impl From<&str> for BackendNonce {
    fn from(nonce: &str) -> Self {
        Self(nonce.to_string())
    }
}

#[cfg(test)]
impl<'a> From<&'a [u8]> for BackendNonce {
    fn from(s: &'a [u8]) -> Self {
        String::from_utf8(s.to_vec()).unwrap().into()
    }
}

impl From<BackendNonce> for String {
    fn from(nonce: BackendNonce) -> Self {
        nonce.0
    }
}

impl std::ops::Deref for BackendNonce {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::fmt::Display for BackendNonce {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(test)]
impl BackendNonce {
    pub fn rand() -> Self {
        Self(rand_nonce(32))
    }
}

#[cfg(test)]
impl Default for BackendNonce {
    fn default() -> Self {
        Self("WE88EvOBzbqGerznM+2P/AadVf7374y0cH19sDSZA2A".to_string())
    }
}

#[cfg(test)]
fn rand_nonce(size: usize) -> String {
    use rand::distributions::{Alphanumeric, DistString};
    let challenge: String = Alphanumeric.sample_string(&mut rand::thread_rng(), size);
    base64::encode_config(challenge, base64::URL_SAFE_NO_PAD)
}
