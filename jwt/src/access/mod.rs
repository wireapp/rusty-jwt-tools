use jwt_simple::prelude::*;

use crate::{jwk_thumbprint::JwkThumbprint, jwt::new_jti, prelude::*};

mod generate;
mod verify;

/// Claims in an access token
///
/// Specified in [OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP)][1]
///
/// [1]: https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-11.html
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
#[cfg_attr(test, derive(Default))]
pub(crate) struct Access {
    /// ACME server nonce
    #[serde(rename = "chal")]
    pub challenge: AcmeNonce,
    /// Hash of the JWK, see [JwkThumbprint]
    #[serde(rename = "cnf")]
    pub cnf: JwkThumbprint,
    /// Proof of possession in form of a Dpop JWT token generated by [RustyJwtTools::generate_dpop_token]
    #[serde(rename = "proof")]
    pub proof: String,
    /// Client identifier as defined in [RFC8693](https://datatracker.ietf.org/doc/html/rfc8693#section-4.3)
    #[serde(rename = "client_id")]
    pub client_id: String,
    /// wire-server API version
    #[serde(rename = "api_version")]
    pub api_version: u32,
    /// Scope as defined in [RFC8693](https://datatracker.ietf.org/doc/html/rfc8693#section-4.2)
    #[serde(rename = "scope")]
    pub scope: String,
    /// Allows passing extra arbitrary data which will end up in access token claims
    #[serde(flatten, skip_serializing_if = "Option::is_none")]
    pub extra_claims: Option<serde_json::Value>,
}

impl Access {
    /// JWT claim 'exp' (expiration) in seconds
    ///
    /// Specified in [RFC 7519 Section 4.1.4: JSON Web Token (JWT)][1]
    /// By default, we're going to use 6 minutes.
    ///
    /// [1]: https://tools.ietf.org/html/rfc7519#section-4.1.4
    #[cfg(test)]
    pub const DEFAULT_EXPIRY: u64 = 360; // 6 minutes

    /// Access token header 'typ'
    const TYP: &'static str = "at+jwt";

    /// Current wire-server API version
    #[cfg(test)]
    pub const DEFAULT_WIRE_SERVER_API_VERSION: u32 = 5;

    /// Current wire-server API version
    pub(crate) const DEFAULT_SCOPE: &'static str = "wire_client_id";

    /// we want "nbf" & "iat" slightly in the past to prevent clock drifts or problems non-monotonic hosts
    pub(crate) const NOW_LEEWAY_SECONDS: u64 = 3600;

    fn into_jwt_claims(
        self,
        client_id: &ClientId,
        nonce: BackendNonce,
        issuer: Htu,
        audience: url::Url,
        expiry: core::time::Duration,
    ) -> JWTClaims<Self> {
        let now = coarsetime::Clock::now_since_epoch() - Duration::from_secs(Self::NOW_LEEWAY_SECONDS);
        let mut claims = Claims::with_custom_claims(self, expiry.into())
            .invalid_before(now)
            .with_jwt_id(new_jti())
            .with_subject(client_id.to_uri())
            .with_nonce(nonce.to_string())
            .with_issuer(issuer)
            .with_audience(audience);
        claims.issued_at = Some(now);
        claims
    }
}
